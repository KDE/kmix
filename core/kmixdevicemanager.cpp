/*
 * KMix -- KDE's full featured mini mixer
 *
 * Copyright 2006-2007 Christian Esken <esken@kde.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "core/kmixdevicemanager.h"

#include <QRegExp>
#include <QTimer>

#include "kmix_debug.h"
#include "core/mixertoolbox.h"
#include "core/mixer.h"

#include <solid/device.h>
#include <solid/devicenotifier.h>


static const int HOTPLUG_DELAY = 500;			// settling delay, milliseconds


KMixDeviceManager *KMixDeviceManager::instance()
{
    static KMixDeviceManager *instance = new KMixDeviceManager();
    return (instance);
}


void KMixDeviceManager::initHotplug()
{
    qCDebug(KMIX_LOG) << "Connecting to Solid";
    connect(Solid::DeviceNotifier::instance(), &Solid::DeviceNotifier::deviceAdded,
            this, &KMixDeviceManager::pluggedSlot);
    connect(Solid::DeviceNotifier::instance(), &Solid::DeviceNotifier::deviceRemoved,
            this, &KMixDeviceManager::unpluggedSlot);
}


QString KMixDeviceManager::getUDI(int num) const
{
    // This is intended to be used for both ALSA and OSS (no other
    // backends currently support hotplugging).  It is in the format
    // "hw:<devnum>" which may or may not correspond to the name of
    // the device that needs to be provided to the backend API or
    // Canberra.  It does for ALSA.
    return (QString("hw:%1").arg(num));
}


static bool isSoundDevice(const QString &udi)
{
    QRegExp rx("/sound/");				// any UDI mentioning sound
    return (udi.contains(rx));
}


static int matchDevice(const QString &udi)
{
    QRegExp rx("/sound/card(\\d+)$");			// match sound card and ID number
    if (!udi.contains(rx)) return (-1);			// UDI not recognised
    return (rx.cap(1).toInt());				// assume conversion succeeds
}


void KMixDeviceManager::pluggedSlot(const QString &udi)
{
    if (!isSoundDevice(udi)) return;			// ignore non-sound devices

    Solid::Device device(udi);
    if (!device.isValid())
    {
        qCWarning(KMIX_LOG) << "Invalid device for UDI" << udi;
        return;
    }

    // Solid device UDIs for a plugged sound card are of the form:
    //
    // ALSA:
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:13.2/usb2/2-4/2-4.1/2-4.1:1.0/sound/card3
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:13.2/usb2/2-4/2-4.1/2-4.1:1.0/sound/card3/pcmC3D0p
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:13.2/usb2/2-1/2-1.3/2-1.3:1.0/sound/card3/controlC3
    //
    // OSS:
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:12.1/usb4/4-2/4-2:1.0/sound/card4
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:12.1/usb4/4-2/4-2:1.0/sound/card4/mixer4
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:12.1/usb4/4-2/4-2:1.0/sound/card4/pcmC4D0p
    //   /org/kde/solid/udev/sys/devices/pci0000:00/0000:00:12.1/usb4/4-2/4-2:1.0/sound/card4/controlC4
    //
    // The first of each of these is considered to be the canonical form and
    // triggers device hotplug, after a settling delay.  The others are ignored.
    //
    // Note that the Solid device UDI is not used anywhere else within KMix,
    // what is referred to as a "UDI" elsewhere is as described in the
    // comment for Mixer::udi() in core/mixer.h and generated by getUDI()
    // above.  Solid only ever supported ALSA and OSS anyway, even in KDE4,
    // so we can assume the driver is one of those here.  See
    // https://community.kde.org/Frameworks/Porting_Notes#Solid_Changes

    const int devnum = matchDevice(udi);
    if (devnum!=-1)
    {
        qCDebug(KMIX_LOG) << "Plugged UDI" << udi;
        const QString ourUDI = getUDI(devnum);
        qCDebug(KMIX_LOG) << "-> our UDI" << ourUDI << "devnum" << devnum;

        // It is not possible to deduce from the Solid UDI whether the hotplug
        // event is being delivered for an ALSA or an OSS device, but somehow
        // we have to find out.
        //
        // The assumption made is that the backend corresponding to the first
        // existing mixer is also appropriate for the newly plugged device.
        // In practice this will be the only "regular" backend (see
        // MixerToolBox::initMixerInternal() for what that means) in use
        // unless the multi driver mode is enabled.  If no mixers are yet
        // active it means that no sound devices were present until now,
        // in which case the preferred (first supported) backend is used.
        //
        // Unfortunately this still may not select the correct backend in the
        // situation where:
        //
        //   1.  KMix is configured to support both ALSA and OSS (and possibly
        //       also PulseAudio, which does not affect the situation).
        //   2.  No sound cards were present at initial KMix startup, therefore
        //       the 'mixers' list below is empty or only contains MPRIS2.
        //   3.  An OSS device is hotplugged.
        //
        // Because KMix cannot know from Solid that the hotplug is of an OSS
        // device, and ALSA is the higher priority driver, ALSA will be used
        // for the new device.  However, it is assumed that OSS will only be
        // in use if the system does not support ALSA and KMix has been built
        // without ALSA support, so using the first supported backend in this
        // rare case is reasonable.
        //
        // TODO: may be able to examine Solid's Block.Device to determine
        // whether ALSA or OSS (see solid-hardware5 list details) applies.
        // This would resolve the ambiguity completely.

        QString backend;
        const QList<Mixer *> mixers = MixerToolBox::mixers();
        if (!mixers.isEmpty())
        {
            const Mixer *mixer = mixers.first();
            // Check for the case that there were initially no "regular"
            // backends active, which means that the first may be MPRIS2.
            if (!mixer->isDynamic()) backend = mixer->getDriverName();
        }
        if (backend.isEmpty()) backend = MixerToolBox::preferredBackend();

        // Action after a short delay to allow hotplug to settle.
        QTimer::singleShot(HOTPLUG_DELAY, [=](){ emit plugged(backend.toLatin1(), ourUDI, devnum); });
    }
    else qCDebug(KMIX_LOG) << "Ignored unrecognised UDI" << udi;
}


void KMixDeviceManager::unpluggedSlot(const QString &udi)
{
    if (!isSoundDevice(udi)) return;			// ignore non-sound devices

    // At this point the device has already been unplugged by the user.
    // Solid doesn't know anything about the device except the UDI, but
    // that can be matched using the same logic as for plugging.
    //
    // This may not work properly in multi driver mode, because UDIs may not
    // be unique among backends.  Since the format for ALSA and OSS is the
    // same (generated by getUDI() above), it is conceivable that ALSA and OSS
    // may each have had a device with the same number, so the loop in
    // KMixWindow::unplugged() would unplug the first one found regardless
    // of which driver caused the unplug event.  However, this configuration
    // is not supported in KMix and is not very useful for either KMix or the
    // system, so there is no need to consider which backend applies here.

    const int devnum = matchDevice(udi);
    if (devnum!=-1)
    {
        qCDebug(KMIX_LOG) << "Unplugged UDI" << udi;
        const QString ourUDI = getUDI(devnum);
        qCDebug(KMIX_LOG) << "-> our UDI" << ourUDI << "devnum" << devnum;
        QTimer::singleShot(HOTPLUG_DELAY, [=](){ emit unplugged(ourUDI); });
    }							// allow hotplug to settle
    else qCDebug(KMIX_LOG) << "Ignored unrecognised UDI" << udi;
}


void KMixDeviceManager::setHotpluggingBackends(const QString &backendName)
{
    qCDebug(KMIX_LOG) << "using" << backendName;
    // Note: this setting is ignored, it is assumed above that
    // Solid only delivers sound card hotplug events for either
    // ALSA or OSS.
    _hotpluggingBackend = backendName;
}
